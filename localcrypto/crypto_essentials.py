'''
This module contains the classes necessary to simulate a cryptocurrency: 
Transaction, Block, CoinBase, MiningNode, and Wallet.
'''

import datetime
import pickle
import socket
import threading
from hashlib import sha256

from Cryptodome.Hash import RIPEMD160
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import serialization

from localcrypto import utils
from localcrypto.constants import (HEADER, REQUEST_BLOCKCHAIN, REQUEST_BLOCK, 
REQUEST_TX, PING_CALL, PING_RESPONSE)


def hash_pub_key(public_key):
    '''
    Generates and returns a hash of public_key. The 
    result of this hash is also called the "address".
    
    public_key : a EllipticCurvePublicKey object from the cryptography library
        A public key
        
    Returns RIPEMD160(SHA256(public_key)).
        dtype : bytes
    '''
    pub_key_hash = public_key.public_bytes(encoding=serialization.Encoding.X962, 
                                           format=serialization.PublicFormat.UncompressedPoint)
    pub_key_hash = sha256(pub_key_hash).digest()
    return RIPEMD160.new(pub_key_hash).hexdigest()

def serialize_pub_key(public_key):
    '''
    public_key : EllipticCurvePublicKey object from cryptography library
    '''
    return public_key.public_bytes(encoding=serialization.Encoding.DER,
                    format=serialization.PublicFormat.SubjectPublicKeyInfo)

def deserialize_pub_key(public_key):
    '''
    public_key : EllipticCurvePublicKey object from cryptography library
    '''
    return serialization.load_der_public_key(data=public_key,
                                            backend=None)

# TODO: Implement the ability to partially spend UTXOs
# TODO: After doing the above, implement the ability to send transaction fees to miners
# TODO: Change the mining protocol so that a block is mined every t minutes and the
#       target difficulty of new blocks are adjusted to meet this goal.
class Transaction():
    '''
    NOTE: A user can only spend one inpt_tx at a time. If they receive
          5 crypto from a transaction, they can send 3 to someone else and
          2 to themselves. If, however, they receive 5 crypto from one tx
          and 4 from another, they cannot send 9 in a single tx.
    NOTE: While public_key is stored as a serialized version of the
          EllipticCurvePublicKey object, when the public_key is used
          to verify a transaction, the deserialized version must be used.
    '''
    def __init__(self, signature, message, public_key, inpt_tx, recipients, amounts):
        '''
        The ith element in amounts will be sent to the ith element in recipients.
        Each element in recipients must be unique; if this condition is not met,
        some funds will be lost.

        signature : byte string
            The digital signature generated by the sender for this message.
        message : byte string
            The message used to generate the signature.
        public_key : the public_bytes attribute of an EllipticCurvePublicKey object
            The sender's public key. Used to unlock inpt_tx.
        inpt_tx : Transaction object
            The transaction to use as input.
        recipients : list of byte strings
            A list of the RIPEMD160(SHA256()) hash of the recipientss public keys.
        amounts : list of int
            The amount of cryptocurrency to send to each recipient.
        '''
        self.tx_id = 1 # TODO: Find a way to give each tx a unique id
        self.signature = signature
        self.message = message
        self.public_key = public_key
        self.inpt_tx = inpt_tx
        self.recipients = recipients
        self.amounts = amounts

        assert len(recipients) == len(amounts)

    def __repr__(self):
        return f'transaction{self.tx_id}.{self.signature[:24]}'

    def pretty_print(self):
        sender = hash_pub_key(self.public_key)
        print(f'{sender} sent {self.amount} to {self.recipient}.')
        print(f'Transaction... {self}')
        print(f'inpt_tx... {self.inpt_tx}')


class Block():
    def __init__(self, prev_block_hash, transactions, timestamp=datetime.datetime.now(), nonce=0):
        '''
        prev_block_hash : str
            A hexidecimal representation of the sha256 hash of the previous block
        transactions : tuple
            A tuple of Transaction objects
        '''
        self.prev_block_hash = prev_block_hash
        self.transactions = transactions
        self.num_transactions = len(transactions)
        self.timestamp = timestamp
        # Difficulty target: 2^240 (or 16 leading 0s in a 256-bit number)
        self.target = 2**240 
        self.nonce = nonce

    def __repr__(self):
        return f'{self.prev_block_hash}{self.timestamp}{self.target}{self.nonce}'

    
class CoinBase():
    '''
    The coinbase can be used to distribute crypto to users.
    '''
    def __init__(self):
        # Generate private and public keys
        self.__private_key = ec.generate_private_key(curve=ec.SECP256K1, 
                                                   backend=default_backend()
                                                  )
        self.public_key = self.__private_key.public_key()
        
    def generate_tx(self, recipients, amounts):
        '''
        Generate a transaction from the coinbase to recipient. A transaction 
        where the coinbase is the sender does not require an input transaction. 
        This function effectively issues crypto, giving it to recipient.
        '''
        inpt_tx = None
        timestamp = str(datetime.datetime.now()).encode()
        recipients_bytes = b''.join([bytes(r, 'utf-8') for r in recipients])
        amounts_bytes = b''.join([bytes(a) for a in amounts])
        message = sha256(b'coinbase'+timestamp+amounts_bytes+recipients_bytes).digest()
        signature = self.__private_key.sign(message, ec.ECDSA(hashes.SHA256()))
        srlzd_pub_key = serialize_pub_key(self.public_key)
        # Create transaction
        return Transaction(signature, message, srlzd_pub_key, inpt_tx, recipients, amounts)


class MiningNode():
    '''
    A mining node verifies transations and mines blocks.
    '''
    def __init__(self, genesis_block, PORT):
        self.genesis_block = genesis_block
        self.main_blockchain = (genesis_block,)
        self.branch_blocks = () # blocks that might replace blocks in main_blockchain
        self.orphan_blocks = () # valid blocks with unknown parents
        self.valid_unconfirmed_txs = () # valid transactions that aren't in a block yet
        self.invalid_txs = ()
        self.peer_blockchains = ()

        # self.neighbor_addrs = [] # tuples of the form (IP_ADDRESS, PORT) representing the addresses of neighboring nodes
        self.neighbors = [] # list of client sockets of neighboring nodes to which this node is currently connected
        
        self.IP_ADDRESS = socket.gethostbyname(socket.gethostname())
        self.PORT = PORT
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind((self.IP_ADDRESS, PORT))

        self.name = 'MiningNode'

    def verify(self, signature, message, public_key):
        '''
        Return True if public_key verifies signature and message, False otherwise
        '''
        # Verify signature and message with public_key
        try:
            public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))
        except InvalidSignature:
            return False
        return True

    def unlock(self, signature, message, public_key, inpt_tx):
        '''
        NOTE: Legacy implementation... This documentation is helpful, though.

        Unlock an unspent transaction output (UTXO). Used by confirm().
        Similar to the following script in the bitcoin Script language:
        <SenderSignature> <SenderPubKey> OP_DUP HASH160 <SenderPubKeyHash> EQUILVERIFY CHECKSIG
        
        signature : byte string
            The digital signature generated by the sender for this message.
        message : byte string
            The message used to generate the signature.
        public_key : cryptography.hazmat.backends.openssl.ec._EllipticCurvePublicKey object
            The sender's public key. Used to unlock inpt.
        inpt_tx : Transaction object
            The transaction to use as input.
        '''
        return
        
        addresses_match = self.addresses_match(public_key, inpt_tx)
        verified = self.verify(signature, message, public_key)
        
        if addresses_match and verified:
            return True
        else:
            return False
    
    def is_double_spend(self, tx):
        # If the tx is in the genesis block, tx cannot be a double spend
        if tx in self.genesis_block.transactions:
            return False

        inpt_tx = tx.inpt_tx

        for block in self.main_blockchain[1:]:
            for t in block.transactions:
                same_inpt_sig = t.inpt_tx.signature == inpt_tx.signature
                same_pub_key = t.public_key == tx.public_key
                if same_inpt_sig and same_pub_key:
                    return True
        for t in self.valid_unconfirmed_txs:
            same_inpt_sig = t.inpt_tx.signature == inpt_tx.signature
            same_pub_key = t.public_key == tx.public_key
            if same_inpt_sig and same_pub_key:
                return True
        return False

    def output_is_gt_inpt(self, tx, sender_address):
        '''
        Return True if tx spends more than the amount the sender of tx
        received from tx.inpt_tx, False otherwise.
        '''
        total_output = sum(tx.amounts)
        sender_address_idx = tx.recipients.index(sender_address)
        total_inpt = tx.inpt_tx.amounts[sender_address_idx]
        if total_output > total_inpt:
            return True
        return False

    def tx_is_known(self, tx):
        # Check main_blockchain
        for block in self.main_blockchain:
            if tx in block.transactions:
                # print('tx in main_blockchain')  # TODO: Delete this line
                return True
        # Check valid_unconfirmed_txs
        if tx in self.valid_unconfirmed_txs:
            # print('tx in valid_unconfirmed_txs')  # TODO: Delete this line
            return True
        # Check invalid_txs
        if tx in self.invalid_txs:
            # print('tx in invalid_txs')  # TODO: Delete this line
            return True
        return False

    def tx_is_valid(self, tx):
        '''
        Determine whether the transaction is valid and whether it uses
        a known UTXO.
        Return False if transaction is invalid or if it uses an unknown 
        UTXO, True otherwise.
        '''
        signature = tx.signature
        message = tx.message
        public_key = deserialize_pub_key(tx.public_key)
        sender_address = hash_pub_key(public_key)
        recipients = tx.recipients
        amounts = tx.amounts
        inpt_tx = tx.inpt_tx

        # Skip certain checks if tx is in genesis_block
        genesis_block = self.main_blockchain[0]
        if tx not in genesis_block.transactions:
            
            if not self.tx_is_known(inpt_tx):
                # print('inpt_tx unknown')
                return False

            # Ensure inpt_tx sent some crypto to the current sender
            if sender_address not in recipients:
                return False

            # Ensure the sender of tx received from inpt_tx at least 
            # as much as tx is sending
            if self.output_is_gt_inpt(tx, sender_address):
                return False

        # Ensure the inputted transaction output has not yet been spent
        if self.is_double_spend(tx):
            # TODO: Return to this method. Make sure it takes into account the lists recipients and amounts
            # print('double spend')
            return False

        # Ensure the digitally signed message can be verified with public_key
        if not self.verify(signature, message, public_key):
            # print('could not verify')
            return False

        positive = [True if amount > 0 else False for amount in amounts]
        if not all(positive):
            return False

        # Unlock the UTXO
        # unlocked = self.unlock(signature, message, public_key, inpt_tx)
        # if not unlocked:
        #     print('locked')
        #     return False
        
        return True
    
    def get_tx(self, tx_id):
        ''' Search main_blockchain for a transaction with tx_id '''
        for block in self.main_blockchain:
            for tx in block.transactions:
                if tx.tx_id == tx_id:
                    return tx
        return None

    def get_block(self, block_hash):
        ''' Search main_blockchain for a block whose hash matches block_hash '''
        for i, block in enumerate(self.main_blockchain):
            if block.prev_block_hash == block_hash:
                candidate = self.main_blockchain[i-1]
                if self.hash_block(candidate) == block_hash:
                    return candidate
                return None

    def block_is_known(self, block):
        if block in self.main_blockchain:
            return True

        elif block in self.branch_blocks:
            return True

        elif block in self.orphan_blocks:
            return True

        return False

    def hash_block(self, block):
        return sha256(bytes(repr(block), 'utf-8')).hexdigest()

    def hash_is_lt_target(self, block):
        ''' 
        Determine whether block hash is less than block target difficulty.
        Return True if hash(block) <= block.target, False otherwise.
        '''
        block_hash = self.hash_block(block)
        block_hash = int(block_hash, base=16)
        if block_hash <= block.target:
            return True
        return False

    def mine_block(self):
        '''
        Generate a new block using the transactions currently in 
        self.valid_unconfirmed_txs. If a block is successfully mined,
        the block will be appended to self.main_blockchain and propagated
        to other nodes. 
        Return Block object if successful, None otherwise.
        '''
        if not self.valid_unconfirmed_txs:
            return

        print(f'[MINING] {self.name} mining block...')

        prev_block = self.main_blockchain[-1]
        prev_block_hash = self.hash_block(prev_block)

        timestamp = datetime.datetime.now()

        nonce_max = 2 ** 32
        for nonce in range(nonce_max):
            candidate_block = Block(prev_block_hash, 
                                    self.valid_unconfirmed_txs, 
                                    timestamp, nonce)
            if self.hash_is_lt_target(candidate_block):
                self.main_blockchain = self.main_blockchain + (candidate_block,)
                self.valid_unconfirmed_txs = ()
                self.propagate(candidate_block)
                print(f'[MINING] {self.name} successfully mined block. ', end='')
                print(f'Propagating block... {candidate_block}')
                return candidate_block
        print(f'[MINING] {self.name} could not mine block...')
        return None

    def is_child(self, child_block, parent_block):
        '''
        Return True if child_block is a child of parent_block, False otherwise.
        '''
        child_hash = self.hash_block(child_block)
        parent_hash = self.hash_block(parent_block)
        if child_hash == parent_hash:
            return True
        return False

    def block_is_valid(self, block):
        ''' 
        Used to confirm that another node's candidate block is valid.
        '''
        if block.timestamp > datetime.datetime.now():
            return False

        return self.hash_is_lt_target(block)

    def parent_block_known(self, block):
        '''
        Return True if block has a parent in main_blockchain, False otherwise
        '''
        for b in reversed(self.main_blockchain):
            if block.prev_block_hash == self.hash_block(b):
                return True
        return False

    def migrate_orphans(self):
        '''
        Scan orphan_blocks for blocks whose parents have been
        found and move those blocks to either main_blockchain
        or branch_blocks.
        '''
        for b in self.orphan_blocks:
            if self.parent_block_known(b):
                orphan_blocks = list(self.orphan_blocks)
                orphan_blocks.remove(b)
                self.orphan_blocks = tuple(orphan_blocks)
                if b.prev_block_hash == self.hash_block(self.main_blockchain[-1]):
                    self.main_blockchain = (self.main_blockchain) + (b,)
                else:
                    self.branch_blocks = (self.branch_blocks) + (b,)

    def get_best_blockchain(self):
        '''
        Request each neighbor node's main_blockchain.
        Compare it with self.main_blockchain. Determine
        which blockchain is best, and return it if it is
        not this node's main_blockchain.
        '''
        if len(self.neighbors) <= 1:
            return None

        # Once the blockchain is large, the entire blockchain
        # will be too big to download by the time
        # all the requests have finished. This is ok
        # because the requested blockchain will be
        # inspected in a future call of get_best_blockchain.
        for neighbor in self.neighbors:
            utils.send(REQUEST_BLOCKCHAIN, neighbor)

        smallest_target_sum = 2**256 * len(self.main_blockchain)
        best_blockchain = self.main_blockchain
        for blockchain in self.peer_blockchains:
            this_target_sum = 0
            for block in blockchain:
                this_target_sum += block.target
            if this_target_sum < smallest_target_sum:
                smallest_target_sum = this_target_sum
                best_blockchain = blockchain

        # Might cause problems if blockchains are received immediately 
        # before the above for loop
        self.peer_blockchains = () 

        if best_blockchain != self.main_blockchain:
            return best_blockchain
        return None

    def run(self):
        global running
        running = True
        try:
            mining_thread = threading.Thread(target=self.mine)
            server_thread = threading.Thread(target=self.run_server)
            mining_thread.start()
            server_thread.start()
        except KeyboardInterrupt:
            print(f'[SHUTTING DOWN] {self.name} is shutting down')
            running = False

    def mine(self):
        print(f'[MINING] {self.name} is running the mining protocol')
        while running:
            self.mine_block()
            
            # Move any orphan blocks whose parents have been found
            # to main_blockchain or branch_blocks
            self.migrate_orphans()

            best_blockchain = self.get_best_blockchain()
            if best_blockchain:
                self.main_blockchain = best_blockchain
        print(f'[KILLED] {self.name} stopped mining')

    def run_server(self):
        '''
        This function handles the server aspects of a node. It listens
        for messages from other nodes and services any requests.
        '''
        print(f'[LISTENING] {self.name} is listening on port {self.PORT}')
        self.server_socket.listen()
        while running:
            client_socket, address = self.server_socket.accept()
            thread = threading.Thread(target=self.handle_client, 
                                        args=(client_socket, address))
            thread.start()
            self.neighbors.append(client_socket)
        print(f'[TERMINATED] {self.name} on port {self.PORT} has been shut down.')

    def handle_client(self, client_socket, address):
        '''
        Receive messages from client. If client sends no messages
        for 5 minutes, ping client. If, after the ping, a message 
        from client is not received within 30s, disconnect from client.

        client_socket : socket object
            The client socket
        address : tuple
            The IP address and port of client socket
        '''
        print(f'[CONNECTED] New neighbor: {address}')
        client_socket.settimeout(300) # timeout after 5 minutes
        while True:
            try:
                msg = utils.receive_message(client_socket)
                self.handle_message(msg, client_socket)
            except socket.timeout:
                # Ping client. If client responds within 30s, continue 
                # looping, else exit.
                utils.send(PING_CALL)
                try:
                    client_socket.settimeout(30)
                    msg = utils.receive_message(client_socket)
                    self.handle_message(msg, client_socket)
                    client_socket.settimeout(300)
                except socket.timeout:
                    client_socket.close()
                    break
            except ValueError: 
                # client disconnected and sent empty string
                client_socket.close()
                break
        print(f'[DISCONNECTED] Neighbor {address} disconnected')
        self.neighbors.remove(client_socket)

    def handle_message(self, msg, client_socket):
        obj = pickle.loads(msg)
        if isinstance(obj, str):
            self.handle_request(client_socket, obj)
        else:
            self.receive(obj)
        
    def handle_request(self, client_socket, msg):
        split_msg = msg.split(' ')

        if msg == PING_CALL:
            utils.send(PING_RESPONSE, client_socket)

        elif msg == REQUEST_BLOCKCHAIN:
            utils.send(self.main_blockchain, client_socket)
        
        elif split_msg[0] == REQUEST_BLOCK:
            # Second element in request is block_hash
            block = self.get_block(split_msg[1])
            utils.send(block, client_socket)

        elif split_msg[0] == REQUEST_TX:
            # Second element in request is tx_id
            tx = self.get_tx(split_msg[1])
            utils.send(tx, client_socket)

    def receive(self, obj):
        ''' Receive incoming blockchain, block, or transaction '''
        if isinstance(obj, tuple):
            self.receive_blockchain(obj)
        elif isinstance(obj, Transaction):
            self.receive_transaction(obj)
        elif isinstance(obj, Block):
            self.receive_block(obj)

    def receive_blockchain(self, blockchain):
        if self.hash_block(blockchain[0]) == self.hash_block(self.genesis_block):
            are_blocks = [True if isinstance(b, Block) else False for b in blockchain]
            if all(are_blocks):
                self.peer_blockchains = self.peer_blockchains + (blockchain,)

    def receive_transaction(self, tx):
        # TODO: Find a way to set tx.tx_id and have a unique id for every tx
        # print(f'{self.name} receiving... {tx}')  # TODO: Delete this line

        if self.tx_is_known(tx):
            # print(f'{self.name} already knows... {tx}')
            return

        if self.tx_is_valid(tx):
            # print(f'{self.name}: valid transaction ... {tx}')
            self.valid_unconfirmed_txs = (self.valid_unconfirmed_txs) + (tx,)
            self.propagate(tx)
        else:
            # print(f'{self.name}: invalid transaction ... {tx}')
            self.invalid_txs = (self.invalid_txs) + (tx,)

        # TODO: Implement the extraction of transaction fees via the difference
        #       between a tx's total input amount and total output amount.
        #       This will require an update of the receive_block() method because
        #       each node that receives a block must verify that the miner is not
        #       extracting more transaction fees than is acceptable. 

    def receive_block(self, block):
        ''' 
        Receive a block and determine whether it is the next 
        block on the blockchain, a valid block with an unknown 
        parent, or invalid. If it is the next block, check 
        orphan_blocks to see if we have its child.
        Return True if the block is new to this node, False otherwise.
        '''
        if self.block_is_known(block):
            return False

        block_is_valid = self.block_is_valid(block)
        is_next_block = self.is_child(block, self.main_blockchain[-1])

        if block_is_valid and is_next_block:
            self.main_blockchain = (self.main_blockchain) + (block,)

        elif block_is_valid and self.parent_block_known(block):
            self.branch_blocks = (self.branch_blocks) + (block,)

        elif block_is_valid:
            self.orphan_blocks = (self.orphan_blocks) + (block,)

        self.propagate(block)
        return True

    def propagate(self, obj):
        for neighbor in self.neighbors:
            utils.send(obj, neighbor)


class Wallet():
    '''
    Naive implementation of a cryptocurrency wallet.
    '''
    def __init__(self):
        # Generate private key, public key, and address (i.e. pub_key_hash)
        self.__private_key = ec.generate_private_key(curve=ec.SECP256K1, 
                                                   backend=default_backend()
                                                  )
        self.public_key = self.__private_key.public_key()
        self.address = hash_pub_key(self.public_key)

        self.blockchain = ()

        # transactions that have already been used as inputs for other transactions
        self.spent_txs = []

    def generate_tx(self, inpt_tx, recipients, amounts):
        '''
        Generate a transaction that sends crypto from this wallet to recipient. 
        Does not propogate the transaction to nodes.
        
        Returns Transaction object.
        '''
        timestamp_bytes = str(datetime.datetime.now()).encode()
        address_bytes = bytes(self.address, 'utf-8')
        recipients_bytes = b''.join([bytes(r, 'utf-8') for r in recipients])
        amounts_bytes = b''.join([bytes(a) for a in amounts])
        message = sha256(address_bytes+timestamp_bytes+amounts_bytes+recipients_bytes).digest()
        signature = self.__private_key.sign(message, ec.ECDSA(hashes.SHA256()))
        srlzd_pub_key = serialize_pub_key(self.public_key)

        tx = Transaction(signature, message, srlzd_pub_key, inpt_tx, recipients, amounts)
        self.spent_txs.append(inpt_tx)
        return tx

    def get_blockchain(self, node_address):
        '''
        Get a blockchain from a node. Stores the blockchain as self.blockchain.

        node_address: tuple
            The first element must be an IPv4 address represented as a string,
            the second element a port number represented as an int.

        Returns the blockchain if successful, None otherwise.
        '''
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(node_address)
        utils.send(REQUEST_BLOCKCHAIN, client_socket)
        return self._receive_blockchain(client_socket)

    def _receive_blockchain(self, socket):
        '''
        socket : socket object
            A socket connected to a mining node; the same socket used to send 
            a request to the node.
        '''
        msg = utils.receive_message(socket)
        obj = pickle.loads(msg)

        if not isinstance(obj, tuple):
            return None

        are_blocks = [isinstance(item, Block) for item in obj]
        if not all(are_blocks):
            return None

        return obj

    def get_unspent_txs(self):
        '''
        Search self.blockchain for transactions sent to this wallet's address
        that have not been spent.

        Return the transactions that have not been spent if successful, None otherwise.
        '''
        received = []
        for block in self.blockchain:
            for tx in block.transactions:
                for r in tx.recipients:
                    if r == self.address:
                        received.append(tx)
        
        return [tx for tx in received if tx not in self.spent_txs]
        
